package pl.wendigo.chrome.protocol

import io.reactivex.BackpressureStrategy
import io.reactivex.Flowable
import io.reactivex.Single
import io.reactivex.schedulers.Schedulers
import io.reactivex.schedulers.Timed
import io.reactivex.subjects.ReplaySubject
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicLong
import okhttp3.OkHttpClient

/**
 * ChromeDebuggerConnection represents connection to chrome's debugger via [DevTools Protocol](https://chromedevtools.github.io/devtools-protocol/).
 *
 * It depends on [FramesStream] which is responsible for providing stream of protocol frames (both events and responses) and allows for sending requests.
 *
 * [FrameMapper] is responsible for decoding/encoding objects to/from JSON frames which DevTools Protocol can understand.
 *
 * @see FramesStream
 * @see FrameMapper
 */
class ChromeDebuggerConnection constructor(
    private val frames: FramesStream,
    private val eventMapper: EventMapper = EventMapper()
) {
    private val nextRequestId = AtomicLong(0)

    /**
     * Registers event name to class mappings.
     */
    fun addEventMapping(name: String, clazz: Class<out Event>) {
        eventMapper.addMapping(name, clazz)
    }

    /**
     * Closes connection to remote debugger.
     */
    fun close() {
        frames.close()
    }

    /**
     * Sends request and captures response.
     */
    fun <T> runAndCaptureResponse(name: String, params: Any?, clazz: Class<T>): Single<T> {
        val request = RequestFrame(
                id = nextRequestId.incrementAndGet(),
                method = name,
                params = params
        )

        return frames.send(request).flatMap { sent ->
            if (sent) {
                frames.getResponse(request, clazz)
            } else {
                Single.error(RequestFailed(request, "Could not enqueue message"))
            }
        }
    }

    /**
     * Captures events by given name and casts received messages to specified class.
     */
    fun <T> captureEvents(name: String, outClazz: Class<T>): Flowable<T> where T : Event {
        return frames.eventFrames()
            .filter { frame -> frame.method == name }
            .map { frame -> eventMapper.deserialize(frame, outClazz) }
            .subscribeOn(Schedulers.io())
    }

    /**
     * Captures all events as generated by remote debugger
     */
    fun captureAllEvents(): Flowable<Event> {
        return frames.eventFrames()
            .map { frame -> eventMapper.deserializeEvent(frame) }
            .subscribeOn(Schedulers.io())
    }

    companion object {
        /**
         * Opens new ChromeDebuggerConnection session for given websocket uri.
         */
        @JvmStatic
        fun openSession(url: String, eventBufferSize: Int = 128): ChromeDebuggerConnection {

            return ChromeDebuggerConnection(
                WebsocketFramesStream(url, ReplaySubject.create(eventBufferSize), FrameMapper(), client),
                EventMapper()
            )
        }

        private val client by lazy {
            OkHttpClient()
        }
    }
}
